"""
PE 61
Created by Taylor Richards
February 28, 2021 
"""

""" ---------------- PROBLEM STATEMENT ----------------

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) 
numbers and are generated by the following formulae:

Triangle	 	P(3,n) =n(n+1)/2	 	1, 3, 6, 10, 15, ...
Square	 	    P(4,n) =n**2	 	1, 4, 9, 16, 25, ...
Pentagonal	 	P(5,n) =n(3n−1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 	P(6,n) =n(2n−1)	 	1, 6, 15, 28, 45, ...
Heptagonal	 	P(7,n) =n(5n−3)/2	 	1, 7, 18, 34, 55, ...
Octagonal	 	P(8,n) =n(3n−2)	 	1, 8, 21, 40, 65, ...
The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

The set is cyclic, in that the last two digits of each number is the first two digits of the next number 
(including the last number with the first).
Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), 
is represented by a different number in the set.
This is the only set of 4-digit numbers with this property.
Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type:
triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number
in the set.

"""
""" ---------------- Discussion ----------------
We are looking for 4-digit numbers. 6 of them. Each one of them is in the range of one of the figurate functions.
they are cyclic, meaning if a = a1a2a3a4 and b = b1b2b3b4, and a precedes b in the order of the set, then
a3a4 = b1b2

Because I am dealing with 4-digit numbers, what if I generate all 4 digit figurate numbers, and then play
with them from there? that seems natural and ez. I should keep in mind that this is NOT a clique problem.
This is a cycle problem - good thing I'm clarifying that now teehee :). So is the art in building the cycle
generator? is that where the combinatorial explosion lurks for this program? Alright, plan: I will try to
solve the three number problem presented in the example. And that should be instructive for as how to proceed.

There may also be something to building all 2 paths, or 3 paths, etc and then figuring out how to combine them
properly. Allow me to explore this idea. taking a and b like above, we would produce a&b. and with that flavour
locked in, we can know ignore the middle 4 numbers, and only try to match this 2 path to another 2 path. Once
we have that, we can try to match our 4-path to another 2 path and we are done? I'm not sure why this way might
fail. This allows us to ignore information, I think...

#there are only 96 triangular numbers that have 4 digits. so there is our upperbound.

NOTE: it is important to remember that order matters in this problem. 

https://stackoverflow.com/questions/12386199/applying-multiple-filters-to-list-of-tuples/35445045

filters = (f1,f2,f3,f4)
filtered_list = filter( lambda x: all(f(x) for f in filters), your_list )

from PE solutions:

def polygon(N, n):
    return ((N-2) * n**2 + (4-N) * n) // 2

"""
""" ---------------- Approach ----------------

I will begin by generating lists of all the appropriately sized (1000 <= k <= 9999) figurate numbers. 

The next list I want to produce is all eligdible pairs of numbers.

- I will create a list of tuples, where the first value is the figurate number, and the 2nd value is the figurate function that generated
  the value. 
- I will then filter this list:
    1. I will make sure that no 2 pairs have the same 2nd value
    2. I will then, of course, only take pairs of pairs that share corresponding numbers. 
    3. I will repeat this to build quads of values.

"""

import time
from itertools import takewhile, product
from operator import itemgetter

start_time = time.time()


#I will try my hand at generator expressions to see how those go. New thingy!!
#I also practiced my takewhile. pretty sweet tbh!! apparently this is not pythonic, but i don't care >:(
# I think I should rewrite this as a map because it's boilerplate-y rn.  
tri_num = [(p, 3) for p in takewhile(lambda p: p < 10000, (int(n*(n+1)/2) for n in range(1000000))) if p > 999]
sq_num = [(p, 4) for p in takewhile(lambda p: p < 10000 , (int(n**2) for n in range(1000000))) if p > 999]
pent_num = [(p, 5) for p in takewhile(lambda p: p < 10000 , (int(n*(3*n-1)/2) for n in range(1000000))) if p > 999]
hex_num = [(p, 6) for p in takewhile(lambda p: p < 10000 , (int(n*(2*n-1)) for n in range(1000000))) if p > 999]
hept_num = [(p, 7) for p in takewhile(lambda p: p < 10000 , (int(n*(5*n-3)/2) for n in range(1000000))) if p > 999]
oct_num = [(p, 8) for p in takewhile(lambda p: p < 10000 , (int(n*(3*n-2)) for n in range(1000000))) if p > 999]

singles = tri_num + sq_num + pent_num + hex_num + hept_num + oct_num

#first lambda ensures that the two numbers aren't from the same figurate function, 
#second lambda checks that the 

filter_lambdas_1 = (lambda x: x[0][1] != x[1][1], lambda x: str(x[0][0])[2:] == str(x[1][0])[:2])
filter_lambdas_2 = (lambda x: len({tup[1] for tups in x for tup in tups}) == 4, lambda x: str(x[0][1][0])[2:] == str(x[1][0][0])[:2])
filter_lambdas_3 = (lambda x: len({tup[1] for tup in x}) == 6, 
                    lambda x: str(x[3][0])[2:] == str(x[4][0])[:2], 
                    lambda x: str(x[5][0])[2:] == str(x[0][0])[:2])

# looks like ((num1,4),(num2,3))
doubles = filter(lambda x: all(f(x) for f in filter_lambdas_1), product(singles, repeat=2))
dblist = list(doubles)

#looks like (((num1,3),(num2,4)),((num3,8), (num4, 7)))
#here, num2[2:] == num3[:2]
quads = filter(lambda x: all(f(x) for f in filter_lambdas_2), product(dblist, repeat=2))
qdlist = list(quads)

#print(list(((x[0][0][0], x[0][0][1], x[0][1][0], x[0][1][1], x[1][0], x[1][1]) for x in product(qdlist, dblist)))[:10])


#Finally, i need to do one more quads X doubles filter, but this time i need to match "the inside and the outside"
#looks like ((num1,3),(num2,4),(num3,8), (num4, 7),(num5, 6),(num6, 5))
# inside and outside match means (num4 match num5) and (num6 match num1)
#I think it is worth my time here to unpack all the layers of tuples so that we have a list of 6-tuples. 
sextuples = filter(lambda x: all(f(x) for f in filter_lambdas_3), 
                    ((x[0][0][0], x[0][0][1], x[0][1][0], x[0][1][1], x[1][0], x[1][1] ) for x in product(qdlist, dblist)))


sxlist = list(sextuples)

sxset = {t[0] for tup in sxlist for t in tup}
result = sum(sxset)

print(result)

print("--- %s seconds ---" % (time.time() - start_time))