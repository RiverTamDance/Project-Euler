"""
Created by Taylor Richards
taylordrichards@gmail.com
March 03, 2025

This is my second attempt at the cuboid route problem. The first attempt was fine, but it would have taken an hour or so to run. I wanted to understand the problem better and do a sleek solution.

see my paper notes for the solution.

"""
import time
from math import gcd, floor, sqrt, ceil

def main():
    start_time = time.perf_counter()

    #print(cuboid_routes(2059))
    print(binary_search(cuboid_routes, 1000000, 100))

    end_time = time.perf_counter()
    print("--- %s seconds ---" % (end_time - start_time))

def cuboid_routes(C):
    triples = primitive_pythagorean_triple(C)

    routes = set()
    for triple in triples:
        routes.update(count_routes(triple, C))

    true_routes = set()
    for route in routes:
        a,b,c = route
        h1 = sqrt((a+b)**2 + c**2)
        h2 = sqrt((a+c)**2 + b**2)
        h3 = sqrt((b+c)**2 + a**2)
        hypotenuses = [h1,h2,h3]

        h = min(hypotenuses)

        if is_integer_num(h):
            true_routes.add(route)

    return(len(true_routes))

def euclids_formula(m, n):
    """generates Pythagorean triples given an arbitrary pair of integers m and n with m > n > 0. 
    The triple generated by Euclid's formula is primitive if and only if m and n are coprime 
    and exactly one of them is even
    """

    if m <= n:
        raise ValueError("m must be greater than n")

    a = m**2-n**2 
    b = 2*m*n
    c = m**2+n**2

    return(a,b,c)

def coprime(m,n):
    if gcd(m,n) == 1:
        return(True)
    else:
        return(False)
    
def only_one_even(m,n):
    return((m % 2 == 0) ^ (n % 2 == 0))
    
def primitive_pythagorean_triple(C):
    """ Generates all primitive pythagorean triples up to m=2*C, n<m using Euclid's formula.
    
    Note: I'm not sure that this is the tightest upperbound for accomplishing this task. 
    Euclid's Formula: a = m**2-n**2, b = 2mn, c = m**2+n**2
    Example: m=2, n=1 corresponds to the triple (3,4,5)

    For a cuboid with dimensions up to C, the largest right angle triangle that may be constructed by "knocking down"
    one of the walls is (l, w+h, hypotenuse) or (w, l+h, hypotenuse) or (h, l+w, hypotenuse)
    """
    
    results = []
    m = 1
    while m <= 2*C:
        n = 1
        while n <= m:
            if only_one_even(m,n):
                if coprime(m,n):
                    results.append(euclids_formula(m,n))
            n += 1
        m += 1

    return(results)

def count_routes(triple, C):

    # a0, b0 = triple[0], triple[1]
    # small_enough = True
    
    # i = 0
    # while small_enough:
    #     i += 1
    #     a = a0*i
    #     b = b0*i

    #     if a > C and b > C:
    #         S1 = 0
    #         S2 = 0
    #     else:
    #         if a > C:
    #             start = a-C if a-C<C+1 else C+1
    #             stop = C+1
    #         elif b <= C:
    #             start = 1
    #             stop = a
    #         else:
    #             start = 0
    #             stop = 0
            
    #         potentials = set([tuple(sorted([i,a-i, b])) for i in range(start,stop)])
    #         S1 = len(potentials)
    #         if b > C:
    #             start = b-C if b-C<C+1 else C+1
    #             stop = C+1
    #         elif a <= C:
    #             start = 1
    #             stop = b
    #         else:
    #             start = 0
    #             stop = 0

    #         potentials = set([tuple(sorted([i,b-i, a])) for i in range(start,stop)])
    #         S2 = len(potentials)

    #     if S1 == 0 and S2 == 0:
    #         small_enough = False
    #     S = S1+S2
    # return(S)

    a, b = triple[0], triple[1]
    # if k < 1:
    #     print(a,b,k, C)
        #raise ValueError("why is k less than 1?")
    small_enough = True
    S=0
    i = 0
    S_prime = set()
    while small_enough:
        i += 1
        ak = a*i
        bk = b*i

        S1 = 0
        S2 = 0
        S1_prime = set()
        S2_prime = set()
        if ak <= C:
            if bk <= 2*C:
                #here we count b's cuboids
                S1 = max(floor(bk/2) - max(bk-C, 1) + 1, 0)
                S1_prime = set([tuple(sorted([i,bk-i, ak])) for i in range(1,bk) if i <= C and bk-i <= C])
                if S1 != len(S1_prime):
                    print("OOPSIE!")
        if bk <= C:
            if ak <= 2*C:
            #here we count a's cuboids
                S2 = max(floor(ak/2) - max(ak-C, 1) + 1, 0)
                S2_prime = set([tuple(sorted([i,ak-i, bk])) for i in range(1,ak) if i <= C and ak-i <= C])
                if S2 != len(S2_prime):
                    print("OOPSIE!")
        S += S1+S2

        S_prime.update(S1_prime, S2_prime)
        if S1 == 0 and S2 == 0:
            small_enough = False
    return(S_prime)

def is_integer_num(n):
    if isinstance(n, int):
        return True
    if isinstance(n, float):
        return n.is_integer()
    return False

def binary_search(fn, target, first_n):
    """I'm going to use doubling as my rough guess technique"""

    guesses = {}

    previous_n = first_n
    guesses[previous_n] = fn(previous_n)
    
    smaller = True
    while smaller:

        current_n = ceil(1.3*previous_n)
        guesses[current_n] = fn(current_n)

        if guesses[current_n] >= target:
            smaller = False
        else:
            previous_n = current_n

    upper_bound = current_n
    lower_bound = previous_n
    #at this point, our current_n has produced a guess larger or equal to our target, so now we need to hone in
    found = False
    while not found:

        midpoint = ceil((upper_bound+lower_bound)/2)
        guesses[midpoint] = fn(midpoint)
        
        if guesses[midpoint] < target:
            lower_bound = midpoint
        else:
            upper_bound = midpoint

        
        if upper_bound-1 == lower_bound and guesses[lower_bound] < target and guesses[upper_bound] >= target:
            found = True
        
    return(lower_bound, guesses[lower_bound], upper_bound, guesses[upper_bound])
if __name__ == "__main__":
    main()